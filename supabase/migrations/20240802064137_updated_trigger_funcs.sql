alter type "public"."workflow_cron_trigger_tables" rename to "workflow_cron_trigger_tables__old_version_to_be_dropped";

create type "public"."workflow_cron_trigger_tables" as enum ('interview_meeting', 'interview_session_relation', 'interview_filter_json', 'candidate_request_availability', 'interview_module_relation', 'interview_training_progress', 'request');

create table "public"."request_completed_event" (
    "id" bigint generated by default as identity not null,
    "completed_at" timestamp with time zone not null default now(),
    "request_id" uuid default gen_random_uuid(),
    "event" workflow_trigger not null
);


alter table "public"."request_completed_event" enable row level security;

alter table "public"."workflow_action_logs" alter column related_table type "public"."workflow_cron_trigger_tables" using related_table::text::"public"."workflow_cron_trigger_tables";

drop type "public"."workflow_cron_trigger_tables__old_version_to_be_dropped";

alter table "public"."candidate_request_availability" alter column "slots" set data type jsonb[] using "slots"::jsonb[];

alter table "public"."interview_meeting" alter column "status" set default 'confirmed'::interview_schedule_status;

alter table "public"."request_relation" alter column "cancel_id" drop default;

CREATE UNIQUE INDEX requests_events_pkey ON public.request_completed_event USING btree (id);

alter table "public"."request_completed_event" add constraint "requests_events_pkey" PRIMARY KEY using index "requests_events_pkey";

alter table "public"."request_completed_event" add constraint "public_requests_events_request_id_fkey" FOREIGN KEY (request_id) REFERENCES request(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."request_completed_event" validate constraint "public_requests_events_request_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.func_on_update_candidate_request_availability_slots()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    wa_record RECORD;
    base_time TIMESTAMP;
    allowed_endpoints TEXT[];
    w_ids uuid[];
    app_job_id uuid;
BEGIN

    -- allowed_endpoints := ARRAY[]::text[];
    -- stop queued jobs
    UPDATE workflow_action_logs
    SET status='stopped'::workflow_cron_run_status
    WHERE status='not_started' 
      AND related_table='candidate_request_availability'::workflow_cron_trigger_tables 
      AND related_table_pkey=NEW.id;

    -- Retrieve application job ID
    SELECT applications.job_id INTO app_job_id
    FROM applications
    WHERE applications.id = NEW.application_id;

    -- Retrieve workflow IDs
    SELECT ARRAY_AGG(w_j_r.workflow_id) AS w_ids
    INTO w_ids
    FROM workflow_job_relation w_j_r
    WHERE w_j_r.job_id = app_job_id;

    -- Process workflows if the status is 'in_progress'
    IF NEW.slots IS NOT NULL AND array_length(NEW.slots, 1) > 0 THEN
        FOR wa_record IN
          SELECT 
            workflow.id AS workflow_id, 
            workflow_action.id AS workflow_action_id, 
            workflow.interval AS interval_minutes, 
            workflow.phase AS phase, 
            workflow.trigger AS trigger, 
            json_build_object(
              'target_api', workflow_action.target_api,
              'payload', workflow_action.payload,
              'candidate_availability_request_id', NEW.id,
              'recruiter_id', workflow.recruiter_id,
              'application_id',new.application_id
            ) AS meta
          FROM workflow
          LEFT JOIN workflow_action ON workflow_action.workflow_id = workflow.id
          WHERE 
            workflow.id = ANY(w_ids)
            AND workflow.is_paused = FALSE
            AND (workflow.trigger::text = 'onReceivingAvailReq')
        LOOP
            PERFORM create_new_workflow_action_log(
              'candidate_request_availability'::workflow_cron_trigger_tables,
              NEW.id,
              wa_record.workflow_id, 
              wa_record.workflow_action_id, 
              wa_record.interval_minutes, 
              wa_record.phase::text, 
              wa_record.meta
            );
        END LOOP;    
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.func_on_update_request()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    wa_record RECORD;
    base_time TIMESTAMP;
    allowed_endpoints TEXT[];
    w_ids uuid[];
    app_job_id uuid;
    req_sess_ids uuid[];
BEGIN
    allowed_endpoints := ARRAY[]::text[];

    -- stop queued jobs
    UPDATE workflow_action_logs
    SET status='stopped'::workflow_cron_run_status
    WHERE status='not_started' 
      AND related_table='request'::workflow_cron_trigger_tables 
      AND related_table_pkey=NEW.id;

    -- Retrieve session IDs
    SELECT ARRAY_AGG(request_relation.session_id)
    INTO req_sess_ids
    FROM request_relation
    WHERE request_relation.request_id = NEW.id;

    -- Retrieve application job ID
    SELECT applications.job_id INTO app_job_id
    FROM applications
    WHERE applications.id = NEW.application_id;

    -- Retrieve workflow IDs
    SELECT ARRAY_AGG(w_j_r.workflow_id) AS w_ids
    INTO w_ids
    FROM workflow_job_relation w_j_r
    WHERE w_j_r.job_id = app_job_id;

    -- Process workflows if the status is 'in_progress'
    IF NEW.status::text = 'in_progress' THEN
        FOR wa_record IN
          SELECT 
            workflow.id AS workflow_id, 
            workflow_action.id AS workflow_action_id, 
            workflow.interval AS interval_minutes, 
            workflow.phase AS phase, 
            workflow.trigger AS trigger, 
            json_build_object(
              'target_api', workflow_action.target_api,
              'payload', workflow_action.payload,
              'request_id', NEW.id,
              'session_ids', req_sess_ids,
              'recruiter_id', workflow.recruiter_id,
              'application_id',new.application_id
            ) AS meta
          FROM workflow
          LEFT JOIN workflow_action ON workflow_action.workflow_id = workflow.id
          WHERE 
            workflow.id = ANY(w_ids)
            AND workflow.is_paused = FALSE
            AND (workflow.trigger::text = 'onAvailReqAgent' OR workflow.trigger::text = 'onSelfScheduleReqAgent')
        LOOP
            PERFORM create_new_workflow_action_log(
              'request'::workflow_cron_trigger_tables,
              NEW.id,
              wa_record.workflow_id, 
              wa_record.workflow_action_id, 
              wa_record.interval_minutes, 
              wa_record.phase::text, 
              wa_record.meta
            );
        END LOOP;    
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.clone_sessions(app_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    company_id uuid;
    session_rec record;
    sesn_reln_record record;
    old_new_session_ids jsonb := '[]'::jsonb;
    app_session_ids uuid[] := '{}';
    appl_job_id uuid;
    int_schedule_id uuid;
    inserted_meeting jsonb;
    inserted_session jsonb;
    inserted_relation jsonb;
    session_data jsonb := '[]'::jsonb;
    session_obj jsonb;
    inserted_sesn_id uuid;
BEGIN
    SELECT interview_schedule.id 
    INTO int_schedule_id  
    FROM interview_schedule
    WHERE interview_schedule.application_id = app_id;
    
    -- clone
    IF int_schedule_id IS NULL THEN 
        int_schedule_id := uuid_generate_v4();
        
        SELECT public_jobs.recruiter_id 
        INTO company_id 
        FROM applications
        LEFT JOIN public_jobs ON public_jobs.id = applications.job_id 
        WHERE applications.id = app_id;

        INSERT INTO interview_schedule(id, application_id, recruiter_id) 
        VALUES (int_schedule_id, app_id, company_id);

        SELECT job_id 
        INTO appl_job_id 
        FROM applications 
        WHERE id = app_id;
        
        FOR session_rec IN
        SELECT 
            interview_session.id AS id,
            interview_session.break_duration,
            interview_session.interviewer_cnt,
            interview_session.location,
            interview_session.module_id,
            interview_session.name,
            interview_session.schedule_type,
            interview_session.session_duration,
            interview_session.session_order,
            interview_session.session_type
        FROM interview_plan
        LEFT JOIN interview_session ON interview_session.interview_plan_id = interview_plan.id
        WHERE interview_plan.job_id = appl_job_id
        LOOP
            -- Insert interview meeting and session within a single SQL command using CTEs
            WITH inserted_meeting_cte AS (
                INSERT INTO interview_meeting (interview_schedule_id, status)
                VALUES (int_schedule_id, 'not_scheduled')
                RETURNING *
            ),
            inserted_session_cte AS (
                INSERT INTO interview_session (
                    break_duration,
                    interviewer_cnt,
                    location,
                    module_id,
                    name,
                    schedule_type,
                    session_duration,
                    session_order,
                    session_type,
                    meeting_id
                )
                VALUES (
                    session_rec.break_duration,
                    session_rec.interviewer_cnt,
                    session_rec.location,
                    session_rec.module_id,
                    session_rec.name,
                    session_rec.schedule_type,
                    session_rec.session_duration,
                    session_rec.session_order,
                    session_rec.session_type,
                    (SELECT id FROM inserted_meeting_cte)
                )
                RETURNING *
            )
            SELECT 
                (SELECT row_to_json(im) FROM inserted_meeting_cte im),
                (SELECT row_to_json(ins) FROM inserted_session_cte ins)
            INTO inserted_meeting, inserted_session;

            session_obj := jsonb_build_object(
                'interview_session', inserted_session,
                'interview_meeting', inserted_meeting,
                'interview_session_relation', '[]'::jsonb
            );

            inserted_sesn_id := (inserted_session->>'id')::uuid;

            old_new_session_ids := old_new_session_ids || jsonb_build_object(
                'old_session_id', session_rec.id::text,
                'new_session_id', inserted_sesn_id::text
            );

            FOR sesn_reln_record IN 
            (
                SELECT 
                    interview_session_relation.interview_module_relation_id,
                    interview_session_relation.interviewer_type,
                    interview_session_relation.user_id,
                    interview_session_relation.training_type
                FROM interview_session_relation 
                WHERE interview_session_relation.session_id = session_rec.id
            )
            LOOP
                INSERT INTO interview_session_relation(
                    interview_module_relation_id,
                    interviewer_type,
                    user_id,
                    training_type,
                    session_id
                ) 
                VALUES (
                    sesn_reln_record.interview_module_relation_id,
                    sesn_reln_record.interviewer_type,
                    sesn_reln_record.user_id,
                    sesn_reln_record.training_type,
                    inserted_sesn_id
                )
                RETURNING row_to_json(interview_session_relation.*) INTO inserted_relation;

                session_obj := session_obj || jsonb_build_object(
                    'interview_session_relation', jsonb_agg(inserted_relation)
                );
            END LOOP;

            session_data := session_data || jsonb_build_array(session_obj);
            app_session_ids := array_append(app_session_ids, inserted_sesn_id);
        END LOOP;
    ELSE
        SELECT jsonb_agg(
            jsonb_build_object(
                'interview_session', row_to_json(interview_session),
                'interview_meeting', row_to_json(interview_meeting),
                'interview_session_relation', (
                    SELECT jsonb_agg(row_to_json(isr))
                    FROM interview_session_relation isr
                    WHERE isr.session_id = interview_session.id
                )
            )
        )
        INTO session_data
        FROM interview_schedule
        LEFT JOIN interview_meeting ON interview_meeting.interview_schedule_id = interview_schedule.id
        LEFT JOIN interview_session ON interview_session.meeting_id = interview_meeting.id
        WHERE interview_schedule.application_id = app_id;
    END IF;

    RETURN jsonb_build_object('old_new_session_ids', old_new_session_ids, 'cloned_sessions', session_data, 'schedule_id', int_schedule_id);
END;
$function$
;

grant delete on table "public"."app_job_id" to "anon";

grant insert on table "public"."app_job_id" to "anon";

grant references on table "public"."app_job_id" to "anon";

grant select on table "public"."app_job_id" to "anon";

grant trigger on table "public"."app_job_id" to "anon";

grant truncate on table "public"."app_job_id" to "anon";

grant update on table "public"."app_job_id" to "anon";

grant delete on table "public"."app_job_id" to "authenticated";

grant insert on table "public"."app_job_id" to "authenticated";

grant references on table "public"."app_job_id" to "authenticated";

grant select on table "public"."app_job_id" to "authenticated";

grant trigger on table "public"."app_job_id" to "authenticated";

grant truncate on table "public"."app_job_id" to "authenticated";

grant update on table "public"."app_job_id" to "authenticated";

grant delete on table "public"."app_job_id" to "service_role";

grant insert on table "public"."app_job_id" to "service_role";

grant references on table "public"."app_job_id" to "service_role";

grant select on table "public"."app_job_id" to "service_role";

grant trigger on table "public"."app_job_id" to "service_role";

grant truncate on table "public"."app_job_id" to "service_role";

grant update on table "public"."app_job_id" to "service_role";

grant delete on table "public"."req_sess_ids" to "anon";

grant insert on table "public"."req_sess_ids" to "anon";

grant references on table "public"."req_sess_ids" to "anon";

grant select on table "public"."req_sess_ids" to "anon";

grant trigger on table "public"."req_sess_ids" to "anon";

grant truncate on table "public"."req_sess_ids" to "anon";

grant update on table "public"."req_sess_ids" to "anon";

grant delete on table "public"."req_sess_ids" to "authenticated";

grant insert on table "public"."req_sess_ids" to "authenticated";

grant references on table "public"."req_sess_ids" to "authenticated";

grant select on table "public"."req_sess_ids" to "authenticated";

grant trigger on table "public"."req_sess_ids" to "authenticated";

grant truncate on table "public"."req_sess_ids" to "authenticated";

grant update on table "public"."req_sess_ids" to "authenticated";

grant delete on table "public"."req_sess_ids" to "service_role";

grant insert on table "public"."req_sess_ids" to "service_role";

grant references on table "public"."req_sess_ids" to "service_role";

grant select on table "public"."req_sess_ids" to "service_role";

grant trigger on table "public"."req_sess_ids" to "service_role";

grant truncate on table "public"."req_sess_ids" to "service_role";

grant update on table "public"."req_sess_ids" to "service_role";

grant delete on table "public"."request_completed_event" to "anon";

grant insert on table "public"."request_completed_event" to "anon";

grant references on table "public"."request_completed_event" to "anon";

grant select on table "public"."request_completed_event" to "anon";

grant trigger on table "public"."request_completed_event" to "anon";

grant truncate on table "public"."request_completed_event" to "anon";

grant update on table "public"."request_completed_event" to "anon";

grant delete on table "public"."request_completed_event" to "authenticated";

grant insert on table "public"."request_completed_event" to "authenticated";

grant references on table "public"."request_completed_event" to "authenticated";

grant select on table "public"."request_completed_event" to "authenticated";

grant trigger on table "public"."request_completed_event" to "authenticated";

grant truncate on table "public"."request_completed_event" to "authenticated";

grant update on table "public"."request_completed_event" to "authenticated";

grant delete on table "public"."request_completed_event" to "service_role";

grant insert on table "public"."request_completed_event" to "service_role";

grant references on table "public"."request_completed_event" to "service_role";

grant select on table "public"."request_completed_event" to "service_role";

grant trigger on table "public"."request_completed_event" to "service_role";

grant truncate on table "public"."request_completed_event" to "service_role";

grant update on table "public"."request_completed_event" to "service_role";

CREATE TRIGGER workflow_on_update_candidate_req_avail_slots AFTER UPDATE OF slots ON public.candidate_request_availability FOR EACH ROW EXECUTE FUNCTION func_on_update_candidate_request_availability_slots();

CREATE TRIGGER workflow_on_update_request AFTER UPDATE OF status ON public.request FOR EACH ROW EXECUTE FUNCTION func_on_update_request();


