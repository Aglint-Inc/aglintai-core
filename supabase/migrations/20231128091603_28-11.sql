drop function if exists "public"."calc_sim_score"(job_ids uuid[], skill_qry_emb vector, edu_qry_emb vector, exp_qry_emb vector, resume_qry_emb vector);

drop function if exists "public"."savegreenhouseresume"();

create table "public"."aggregated_data" (
    "jsonb_agg" jsonb
);


create table "public"."env" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text,
    "value" text
);


create table "public"."function" (
    "value" text
);


create table "public"."result" (
    "jsonb_agg" jsonb
);


alter table "public"."candidate_search_history" drop column "search_query";

alter table "public"."candidate_search_history" add column "bookmarked_candidates" text[] default '{}'::text[];

alter table "public"."candidate_search_history" add column "query_json" jsonb;

alter table "public"."candidate_search_history" add column "search_results" jsonb[] default '{}'::jsonb[];

alter table "public"."job_applications" alter column "candidate_id" set not null;

alter table "public"."public_jobs" drop column "embedding";

alter table "public"."threads" add column "applied" boolean;

alter table "public"."threads" add column "candidate_email" text;

alter table "public"."threads" add column "candidate_name" text;

alter table "public"."threads" add column "candidate_phone" text;

alter table "public"."threads" add column "chat_end" boolean;

alter table "public"."threads" add column "linkedin_url" text;

CREATE UNIQUE INDEX env_pkey ON public.env USING btree (id);

alter table "public"."env" add constraint "env_pkey" PRIMARY KEY using index "env_pkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.batchsavegreenhouse()
 RETURNS jsonb[]
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB[];
BEGIN
    -- Initialize an empty JSONB array for the results
    result := ARRAY[]::JSONB[];

    -- Select up to 50 records that meet the specified conditions
    SELECT ARRAY_AGG(row_to_json(data))
    INTO result
    FROM (
        SELECT
           application_id AS application_id,
           resume AS resume
       FROM greenhouse_reference
       WHERE resume_saved = false and resume is not null
       ORDER BY created_at ASC
       LIMIT 100
    ) as data;

    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.batchscorecron(function_value text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    request_results JSONB;  -- Variable to store the HTTP request result
    function_url text;
BEGIN
    -- Retrieve the URL from the environment variable
    SELECT value INTO function_url FROM env WHERE name = 'resumecron-batchscore';
    -- Make an HTTP POST request
     request_results := net.http_post(
            url := function_url,
            body := jsonb_build_object('function', function_value)
            -- Optionally, add headers or other parameters if required
    );
    -- Return the HTTP request result
    RETURN request_results;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.batchtriggergreenhouse()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    request_results JSONB;  -- Variable to store the HTTP request result
    function_url text;
BEGIN
    -- Make a single HTTP request for the aggregated data
    
    SELECT value INTO function_url FROM env WHERE name = 'greenhouse-batchsave';

    -- Make a single HTTP request for the aggregated data
    request_results := net.http_post(
        url := function_url
        -- Add other parameters like headers or data if needed
    );

    -- Return the HTTP request result
    RETURN request_results;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calc_cosine_sim(emb1 vector, emb2 vector)
 RETURNS TABLE(similarity double precision)
 LANGUAGE plpgsql
AS $function$ begin return query 
select
  coalesce(1 -(emb1 <=> emb2), 0);

end;
$function$
;

CREATE OR REPLACE FUNCTION public.calc_sim_score(job_ids uuid[], skill_qry_emb vector, edu_qry_emb vector, exp_qry_emb vector, resume_qry_emb vector, max_records integer DEFAULT 25, ts_query text DEFAULT ''::text, filter_companies text DEFAULT ''::text)
 RETURNS TABLE(application_id uuid, created_at text, first_name citext, last_name citext, job_title text, email citext, resume_link text, json_resume jsonb, profile_image text, candidate_id uuid, job_id uuid, similarity double precision, sim_exp double precision, sim_res double precision, sim_skills double precision, sim_educ double precision)
 LANGUAGE plpgsql
AS $function$ 
BEGIN 
  RETURN QUERY 
    SELECT DISTINCT ON (ja.candidate_id)
      ja.application_id,
      ja.created_at::text,
      c.first_name,
      c.last_name,
      COALESCE(ja.json_resume->'basics'->>'currentJobTitle', ''),
      c.email,
      ja.resume,
      ja.json_resume,
      c.profile_image,
      ja.candidate_id,
      ja.job_id,
      (
        (
          COALESCE(1 - (ja.experience_embedding <=> exp_qry_emb), 0) * 0.5 +
          COALESCE(1 - (ja.resume_embedding <=> resume_qry_emb), 0) * 0.2 +
          COALESCE(1 - (ja.skills_embedding <=> skill_qry_emb), 0) * 0.2 + 
          COALESCE(1 - (ja.education_embedding <=> edu_qry_emb), 0) * 0.1 
        )
      ) AS similarity,
      COALESCE(1 - (ja.experience_embedding <=> exp_qry_emb), 0),
      COALESCE(1 - (ja.resume_embedding <=> resume_qry_emb), 0),
      COALESCE(1 - (ja.skills_embedding <=> skill_qry_emb), 0),
      COALESCE(1 - (ja.education_embedding <=> edu_qry_emb), 0)
    FROM
      job_applications ja
      JOIN candidates c ON ja.candidate_id = c.id
    WHERE
      ja.job_id = ANY(job_ids) AND
      to_tsvector(COALESCE(lower(ja.json_resume->'basics'->>'currentJobTitle'), '')) @@ to_tsquery('english', ts_query) AND
      CASE
        WHEN LENGTH(filter_companies) > 0 THEN to_tsvector(COALESCE(lower(ja.resume_text),'')) @@ to_tsquery('english', filter_companies)
        ELSE true 
      END
    ORDER BY ja.candidate_id, similarity DESC
    LIMIT max_records;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.filter_candidates(job_ids uuid[], max_records numeric DEFAULT 100)
 RETURNS TABLE(application_id uuid, created_at text, first_name citext, last_name citext, job_title text, email citext, resume_link text, json_resume jsonb, profile_image text, candidate_id uuid, job_id uuid)
 LANGUAGE plpgsql
AS $function$ 
BEGIN 
  RETURN QUERY 
    SELECT DISTINCT ON (ja.candidate_id)
      ja.application_id,
      ja.created_at::text,
      c.first_name,
      c.last_name,
      COALESCE(ja.json_resume->'basics'->>'currentJobTitle', ''),
      c.email,
      ja.resume,
      ja.json_resume,
      c.profile_image,
      ja.candidate_id,
      ja.job_id
    FROM
      job_applications ja
      JOIN candidates c ON ja.candidate_id = c.id
    WHERE
      ja.job_id = ANY(job_ids)
    ORDER BY ja.candidate_id
    LIMIT max_records;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.getjobapplicationcountforcandidates(candidate_ids uuid[])
 RETURNS TABLE(candidate_id uuid, job_ids uuid[], job_titles text[])
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        ja.candidate_id,
        ARRAY_AGG(pj.id) AS job_ids,
        ARRAY_AGG(pj.job_title) AS job_titles
    FROM
        job_applications AS ja
    JOIN
        public_jobs AS pj ON ja.job_id = pj.id
    WHERE
        ja.candidate_id = ANY(candidate_ids)
    GROUP BY
        ja.candidate_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.overviewgenerate()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    aggregated_data JSONB;  -- Variable to store the aggregated JSON data
    request_results JSONB;  -- Variable to store the HTTP request result
BEGIN
    -- Aggregate the selected application data into a JSON array
    SELECT json_agg(row_to_json(test)) 
    INTO aggregated_data  -- Store the result into aggregated_data
    FROM (
        SELECT
            application_id,
            json_resume
        FROM job_applications
        WHERE json_resume IS NOT NULL  AND json_resume->>'basics' IS NOT NULL AND json_resume->>'positions' IS NOT NULL  AND json_resume->>'skills' IS NOT NULL AND json_resume->>'overview' IS NULL 
        ORDER BY created_at DESC
        LIMIT 50
    ) as test;

    -- Make a single HTTP request for the aggregated data
    SELECT
        net.http_post(
            url := 'https://preprod.aglinthq.com/api/google/overview-handler',
            body := aggregated_data  -- Use aggregated_data here
        ) INTO request_results;

    -- Return the HTTP request result
    RETURN request_results;
END;
$function$;

drop function if exists public.batchcalcresumejdscore;

CREATE OR REPLACE FUNCTION public.batchcalcresumejdscore()
 RETURNS jsonb[]
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB[];
BEGIN
    -- Initialize an empty JSONB array for the results
    result := ARRAY[]::JSONB[];

    -- Select up to 50 records that meet the specified conditions
    SELECT ARRAY_AGG(row_to_json(data))
    INTO result
    FROM (
        SELECT
           ja.application_id AS application_id,
           ja.candidate_id AS candidate_id,
           ja.jd_score AS jd_score,
           ja.resume AS resume,
           ja.json_resume AS json_resume,
           ja.resume_text AS resume_text,
           ja.job_id as job_id,
           pj.company as company,
           pj.jd_json as jd_json,
           0 as retry
       FROM job_applications ja
       JOIN public_jobs pj ON ja.job_id = pj.id
       WHERE ja.api_status='not started' and ja.resume is not null  and pj.jd_json is not null
       ORDER BY ja.created_at ASC
       LIMIT 50
    ) as data;

    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_resume_score(score_json jsonb, app_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
    weight_record jsonb;
    total_score numeric := 0;
BEGIN
    -- Fetching weights from the database
    SELECT
        pj.parameter_weights
    INTO
        weight_record
    FROM
        job_applications ja
    JOIN
        public_jobs pj ON ja.job_id = pj.id
    WHERE
        ja.application_id = app_id;

    -- Checking if the record exists
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;

    -- Checking and handling missing keys in score_json
    IF NOT (score_json->>'skills' IS NOT NULL AND score_json->>'project' IS NOT NULL AND score_json->>'education' IS NOT NULL AND score_json->>'experience' IS NOT NULL AND score_json->>'certifications' IS NOT NULL) THEN
        -- Handle missing keys here (set default values or skip the calculation)
        -- For simplicity, we'll set default values to 0 in this example
        RETURN FALSE;
    END IF;

    -- Calculating the total score
    total_score :=
       TRUNC(((score_json->>'skills')::numeric * COALESCE((weight_record->>'skills')::numeric, 0) +
        (score_json->>'project')::numeric * COALESCE((weight_record->>'project')::numeric, 0) +
        (score_json->>'education')::numeric * COALESCE((weight_record->>'education')::numeric, 0) +
        (score_json->>'experience')::numeric * COALESCE((weight_record->>'experience')::numeric, 0) +
        (score_json->>'certifications')::numeric * COALESCE((weight_record->>'certifications')::numeric, 0))/100,0);

    -- Updating the job_applications table with the calculated score
    UPDATE job_applications
    SET resume_score = total_score,
    jd_score = score_json,
    api_status = 'success'
    WHERE application_id = app_id;

    -- Returning true for success
    RETURN true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.embeddingresume()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB;
    request_results JSONB;
    app_data RECORD;
BEGIN
    -- Initialize an empty JSON array for the results
    result := '[]'::JSONB;

    -- Loop through the selected application data
    FOR app_data IN (
       SELECT
           application_id AS application_id,
           json_resume AS resume_json
       FROM job_applications
       WHERE application_id='dc5c1c72-6e7b-4e14-94d8-c8df60eb79f1'
       ORDER BY created_at ASC
       LIMIT 50
    )
    LOOP
        -- Convert the row to JSON
        request_results := row_to_json(app_data);
        
        -- Make the HTTP request for each application data
        SELECT
            net.http_post(
                url := 'https://preprod.aglinthq.com/api/ai/resume-embedding',
                body := request_results
            ) INTO request_results;
        
        -- Append the request result to the result array
        result := result || jsonb_build_object('request_result', request_results);
    END LOOP;


    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;

drop function if exists public.retrybatchcalcresumejdscore;

CREATE OR REPLACE FUNCTION public.retrybatchcalcresumejdscore()
 RETURNS jsonb[]
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB[];
BEGIN
    -- Initialize an empty JSONB array for the results
    result := ARRAY[]::JSONB[];

    -- Select up to 50 records that meet the specified conditions
    SELECT ARRAY_AGG(row_to_json(data))
    INTO result
    FROM (
        SELECT
           ja.application_id AS application_id,
           ja.candidate_id AS candidate_id,
           ja.jd_score AS jd_score,
           ja.resume AS resume,
           ja.json_resume AS json_resume,
           ja.resume_text AS resume_text,
           ja.job_id as job_id,
           pj.company as company,
           pj.jd_json as jd_json,
           1 as retry
       FROM job_applications ja
       JOIN public_jobs pj ON ja.job_id = pj.id
       WHERE ja.api_status in ('failed')  and retry < 1 and pj.jd_json is not null
       ORDER BY ja.created_at ASC
       LIMIT 25
    ) as data;

    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;
drop function if exists public.secondretrybatchcalcresumejdscore;

CREATE OR REPLACE FUNCTION public.secondretrybatchcalcresumejdscore()
 RETURNS jsonb[]
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB[];
BEGIN
    -- Initialize an empty JSONB array for the results
    result := ARRAY[]::JSONB[];

    -- Select up to 50 records that meet the specified conditions
    SELECT ARRAY_AGG(row_to_json(data))
    INTO result
    FROM (
       SELECT
          ja.application_id AS application_id,
           ja.candidate_id AS candidate_id,
           ja.jd_score AS jd_score,
           ja.resume AS resume,
           ja.json_resume AS json_resume,
           ja.resume_text AS resume_text,
           ja.job_id as job_id,
           pj.company as company,
           jsonb_build_object('description', pj.description, 'skills', pj.skills, 'job_title', pj.job_title) AS jd_json,
           2 as retry
       FROM job_applications ja
       JOIN public_jobs pj ON ja.job_id = pj.id
       WHERE ja.api_status in ('failed')  and retry >= 1 and retry < 2 and pj.jd_json is not null
       ORDER BY ja.created_at ASC
       LIMIT 10
    ) as data;

    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;


