create table "public"."greenhouse_reference" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "application_id" uuid not null,
    "public_job_id" uuid not null,
    "posting_id" text not null,
    "greenhouse_id" text not null,
    "resume" text,
    "resume_saved" boolean not null default false
);


create table "public"."weight_record" (
    "jd_score" jsonb,
    "parameter_weights" jsonb
);


CREATE UNIQUE INDEX greenhouse_reference_pkey ON public.greenhouse_reference USING btree (id);

alter table "public"."greenhouse_reference" add constraint "greenhouse_reference_pkey" PRIMARY KEY using index "greenhouse_reference_pkey";

alter table "public"."greenhouse_reference" add constraint "greenhouse_reference_application_id_fkey" FOREIGN KEY (application_id) REFERENCES job_applications(application_id) ON DELETE CASCADE not valid;

alter table "public"."greenhouse_reference" validate constraint "greenhouse_reference_application_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.calculate_resume_score(score_json jsonb, app_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
    weight_record jsonb;
    total_score numeric := 0;
BEGIN
    -- Fetching weights from the database
    SELECT
        pj.parameter_weights
    INTO
        weight_record
    FROM
        job_applications ja
    JOIN
        public_jobs pj ON ja.job_id = pj.id
    WHERE
        ja.application_id = app_id;

    -- Checking if the record exists
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;

    -- Checking and handling missing keys in score_json
    IF NOT (score_json->>'skills' IS NOT NULL AND score_json->>'project' IS NOT NULL AND score_json->>'education' IS NOT NULL AND score_json->>'experience' IS NOT NULL AND score_json->>'certifications' IS NOT NULL) THEN
        -- Handle missing keys here (set default values or skip the calculation)
        -- For simplicity, we'll set default values to 0 in this example
        RETURN FALSE;
    END IF;

    -- Calculating the total score
    total_score :=
       ROUND(((score_json->>'skills')::numeric * COALESCE((weight_record->>'skills')::numeric, 0) +
        (score_json->>'project')::numeric * COALESCE((weight_record->>'project')::numeric, 0) +
        (score_json->>'education')::numeric * COALESCE((weight_record->>'education')::numeric, 0) +
        (score_json->>'experience')::numeric * COALESCE((weight_record->>'experience')::numeric, 0) +
        (score_json->>'certifications')::numeric * COALESCE((weight_record->>'certifications')::numeric, 0))/100,0);

    -- Updating the job_applications table with the calculated score
    UPDATE job_applications
    SET resume_score = total_score,
    jd_score = score_json,
    api_status = 'success'
    WHERE application_id = app_id;

    -- Returning true for success
    RETURN true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_job_applications(query_embedding vector, match_threshold double precision, match_count integer, job_ids uuid[])
 RETURNS TABLE(application_id uuid, first_name text, last_name text, job_title text, email text, json_resume json, similarity double precision)
 LANGUAGE sql
 STABLE
AS $function$
  SELECT
    ja.application_id,
    c.first_name,
    c.last_name,
    c.job_title,
    c.email,
    ja.json_resume,
    1 - (ja.resume_embedding <=> query_embedding) AS similarity
  FROM
    job_applications ja
    JOIN candidates c ON ja.candidate_id = c.id
  WHERE
    1 - (ja.resume_embedding <=> query_embedding) > match_threshold
    AND ja.job_id = ANY(job_ids) AND ja.json_resume is not null
  ORDER BY similarity DESC
  LIMIT match_count;
$function$
;

CREATE OR REPLACE FUNCTION public.savegreenhouseresume()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB;
    request_results JSONB;
    app_data RECORD;
BEGIN
    -- Initialize an empty JSON array for the results
    result := '[]'::JSONB;

    -- Loop through the selected application data
    FOR app_data IN (
       SELECT
           application_id AS application_id,
           resume AS resume
       FROM greenhouse_reference
       WHERE resume_saved = false
       ORDER BY created_at ASC
       LIMIT 50
    )
    LOOP
        -- Convert the row to JSON
        request_results := row_to_json(app_data);
        
        -- Make the HTTP request for each application data
        SELECT
            net.http_post(
                url := 'https://preprod.aglinthq.com/api/greenhouse/saveResume',
                body := request_results
            ) INTO request_results;

        -- UPDATE greenhouse_reference
        -- SET resume_saved = true
        -- WHERE application_id = app_data.application_id;
        
        -- Append the request result to the result array
        result := result || jsonb_build_object('request_result', request_results);
    END LOOP;


    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.levercandidatesync()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
    DECLARE
        result JSONB;
        request_results JSONB;
        app_id UUID;
    BEGIN
        -- Initialize an empty JSON array for the results
        result := '[]'::JSONB;

        -- Loop through the selected application IDs
        FOR app_id IN (
            SELECT job_id
            FROM lever_job_reference
            ORDER BY created_at ASC
        )
        LOOP
            -- Make the HTTP request for each application_id
            SELECT
                net.http_post(
                    url := 'https://preprod.aglinthq.com/api/lever/candidateSync',
                    body := jsonb_build_object('job_id', app_id)
                ) INTO request_results;

            -- Append the request result to the result array
            result := result || jsonb_build_object('request_result', request_results);
        END LOOP;

        -- Return the final result as a JSONB array
        RETURN result;
    END;
    $function$
;


