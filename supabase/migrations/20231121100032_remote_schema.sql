create sequence "public"."documents_id_seq";

alter table "public"."job_applications" drop constraint "job_applications_candidate_id_fkey";

create table "public"."candidate_search_history" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "recruiter_id" uuid not null,
    "search_query" text,
    "is_search_jd" boolean default false
);


create table "public"."documents" (
    "id" bigint not null default nextval('documents_id_seq'::regclass),
    "content" text,
    "metadata" jsonb,
    "embedding" vector(1536)
);


create table "public"."threads" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "thread_id" text,
    "assistant_id" text
);


alter table "public"."job_applications" add column "education_embedding" vector(1536);

alter table "public"."job_applications" add column "experience_embedding" vector(1536);

alter table "public"."job_applications" add column "is_embedding" boolean not null default false;

alter table "public"."job_applications" add column "skills_embedding" vector(1536);

alter table "public"."recruiter" add column "assistant_id" text;

alter sequence "public"."documents_id_seq" owned by "public"."documents"."id";

CREATE UNIQUE INDEX "Threads_pkey" ON public.threads USING btree (id);

CREATE UNIQUE INDEX candidate_search_history_pkey ON public.candidate_search_history USING btree (id);

CREATE UNIQUE INDEX documents_pkey ON public.documents USING btree (id);

alter table "public"."candidate_search_history" add constraint "candidate_search_history_pkey" PRIMARY KEY using index "candidate_search_history_pkey";

alter table "public"."documents" add constraint "documents_pkey" PRIMARY KEY using index "documents_pkey";

alter table "public"."threads" add constraint "Threads_pkey" PRIMARY KEY using index "Threads_pkey";

alter table "public"."candidate_search_history" add constraint "candidate_search_history_recruiter_id_fkey" FOREIGN KEY (recruiter_id) REFERENCES recruiter(id) not valid;

alter table "public"."candidate_search_history" validate constraint "candidate_search_history_recruiter_id_fkey";

alter table "public"."job_applications" add constraint "job_applications_candidate_id_fkey" FOREIGN KEY (candidate_id) REFERENCES candidates(id) not valid;

alter table "public"."job_applications" validate constraint "job_applications_candidate_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.calc_sim_score(job_ids uuid[], skill_qry_emb vector, edu_qry_emb vector, exp_qry_emb vector, resume_qry_emb vector)
 RETURNS TABLE(application_id uuid, created_at text, first_name citext, last_name citext, job_title text, email citext, json_resume jsonb, profile_image text, similarity double precision)
 LANGUAGE plpgsql
AS $function$ begin return query
select
  ja.application_id,
ja.created_at::text,
  c.first_name,
  c.last_name,
  COALESCE(ja.json_resume->'basics'->>'currentJobTitle', ''),
  c.email,
  ja.json_resume,
  c.profile_image,
  (
    (
      coalesce(1 -(ja.resume_embedding <=> resume_qry_emb), 0) + coalesce(1 -(ja.skills_embedding <=> skill_qry_emb), 0) + coalesce(1 -(ja.education_embedding <=> edu_qry_emb), 0) + coalesce(1 -(ja.experience_embedding <=> exp_qry_emb), 0)
    ) / 4
  ) as similarity
from
  job_applications ja
  JOIN candidates c ON ja.candidate_id = c.id
where
  ja.job_id = ANY(job_ids)
ORDER BY
  similarity DESC;

end;
$function$
;

CREATE OR REPLACE FUNCTION public.embeddingresume()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB;
    request_results JSONB;
    app_data RECORD;
BEGIN
    -- Initialize an empty JSON array for the results
    result := '[]'::JSONB;

    -- Loop through the selected application data
    FOR app_data IN (
       SELECT
           application_id AS application_id,
           json_resume AS resume_json
       FROM job_applications
       WHERE is_embedding = false and json_resume is not null
       ORDER BY created_at ASC
       LIMIT 50
    )
    LOOP
        -- Convert the row to JSON
        request_results := row_to_json(app_data);
        
        -- Make the HTTP request for each application data
        SELECT
            net.http_post(
                url := 'https://preprod.aglinthq.com/api/ai/resume-embedding',
                body := request_results
            ) INTO request_results;
        
        -- Append the request result to the result array
        result := result || jsonb_build_object('request_result', request_results);
    END LOOP;


    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.kw_match_documents(query_text text, match_count integer)
 RETURNS TABLE(id uuid, content text, metadata jsonb, similarity real, json_resume jsonb)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY EXECUTE
    FORMAT('SELECT application_id AS id, content, jsonb_build_object(''application_id'',application_id,''json_resume'', json_resume,''first_name'',c.first_name, ''last_name'',c.last_name,''email'',c.email, ''job_title'',c.job_title,''profile_image'',profile_image) AS metadata, ts_rank(to_tsvector(content), plainto_tsquery($1)) AS similarity, json_resume
            FROM job_applications
            JOIN candidates c ON job_applications.candidate_id = c.id
            WHERE to_tsvector(content) @@ plainto_tsquery($1)
            ORDER BY similarity DESC
            LIMIT $2')
    USING query_text, match_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_documents(query_embedding vector, match_count integer DEFAULT 500, filter jsonb DEFAULT '{}'::jsonb)
 RETURNS TABLE(id uuid, content text, metadata jsonb, similarity double precision, json_resume jsonb)
 LANGUAGE plpgsql
AS $function$
#variable_conflict use_column
begin
  return query
  select
    job_applications.application_id as id,
    content,
    json_resume as metadata,
    1 - (job_applications.resume_embedding <=> query_embedding) as similarity,
    json_resume
  from job_applications
  where metadata @> filter
  order by job_applications.resume_embedding <=> query_embedding
  limit match_count;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.secondretrybatchcalcresumejdscore()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB;
    request_results JSONB;
    app_data RECORD;
BEGIN
    -- Initialize an empty JSON array for the results
    result := '[]'::JSONB;

    -- Loop through the selected application data
    FOR app_data IN (
       SELECT
           ja.application_id AS application_id,
           ja.candidate_id AS candidate_id,
           ja.jd_score AS jd_score,
           ja.resume AS resume,
           ja.json_resume AS json_resume,
           ja.resume_text AS resume_text,
           jsonb_build_object('description', pj.description, 'skills', pj.skills, 'job_title', pj.job_title) AS jd_json,
           2 as retry
       FROM job_applications ja
       JOIN public_jobs pj ON ja.job_id = pj.id
       WHERE ja.api_status in ('failed','processing')  and retry >= 1 and retry < 2
       ORDER BY ja.created_at ASC
       LIMIT 10
    )
    LOOP
        -- Convert the row to JSON
        request_results := row_to_json(app_data);
        
        -- Make the HTTP request for each application data
        SELECT
            net.http_post(
                url := 'https://northamerica-northeast2-aglint-cloud-381414.cloudfunctions.net/process_resume_and_jd_v1',
                body := request_results
            ) INTO request_results;

        UPDATE job_applications
            SET 
                processed_at = CURRENT_TIMESTAMP,
                retry = 2
            WHERE application_id = app_data.application_id;
        
        -- Append the request result to the result array
        result := result || jsonb_build_object('request_result', request_results);
    END LOOP;


    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.batchcalcresumejdscore()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB;
    request_results JSONB;
    app_data RECORD;
BEGIN
    -- Initialize an empty JSON array for the results
    result := '[]'::JSONB;

    -- Loop through the selected application data
    FOR app_data IN (
       SELECT
           ja.application_id AS application_id,
           ja.candidate_id AS candidate_id,
           ja.jd_score AS jd_score,
           ja.resume AS resume,
           ja.json_resume AS json_resume,
           ja.resume_text AS resume_text,
           jsonb_build_object('description', pj.description, 'skills', pj.skills, 'job_title', pj.job_title) AS jd_json,
           0 as retry
       FROM job_applications ja
       JOIN public_jobs pj ON ja.job_id = pj.id
       WHERE ja.api_status = 'not started' AND ja.resume IS NOT NULL
       ORDER BY ja.created_at ASC
       LIMIT 50
    )
    LOOP
        -- Convert the row to JSON
        request_results := row_to_json(app_data);
        
        -- Make the HTTP request for each application data
        SELECT
            net.http_post(
                url := 'https://northamerica-northeast2-aglint-cloud-381414.cloudfunctions.net/process_resume_and_jd_v1',
                body := request_results
            ) INTO request_results;

        -- UPDATE job_applications
        -- SET api_status = 'processing',processed_at = current_timestamp
        -- WHERE application_id = app_data.application_id;
        
        -- Append the request result to the result array
        result := result || jsonb_build_object('request_result', request_results);
    END LOOP;


    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.retrybatchcalcresumejdscore()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB;
    request_results JSONB;
    app_data RECORD;
BEGIN
    -- Initialize an empty JSON array for the results
    result := '[]'::JSONB;

    -- Loop through the selected application data
    FOR app_data IN (
       SELECT
           ja.application_id AS application_id,
           ja.candidate_id AS candidate_id,
           ja.jd_score AS jd_score,
           ja.resume AS resume,
           ja.json_resume AS json_resume,
           ja.resume_text AS resume_text,
           jsonb_build_object('description', pj.description, 'skills', pj.skills, 'job_title', pj.job_title) AS jd_json,
           1 as retry
       FROM job_applications ja
       JOIN public_jobs pj ON ja.job_id = pj.id
       WHERE ja.api_status in ('failed','processing')  and retry < 1
       ORDER BY ja.created_at ASC
       LIMIT 25
    )
    LOOP
        -- Convert the row to JSON
        request_results := row_to_json(app_data);
        
        -- Make the HTTP request for each application data
        SELECT
            net.http_post(
                url := 'https://northamerica-northeast2-aglint-cloud-381414.cloudfunctions.net/process_resume_and_jd_v1',
                body := request_results
            ) INTO request_results;

        -- UPDATE job_applications
        --     SET 
        --         processed_at = CURRENT_TIMESTAMP,
        --         retry = retry + 1
        --     WHERE application_id = app_data.application_id;
        
        -- Append the request result to the result array
        result := result || jsonb_build_object('request_result', request_results);
    END LOOP;


    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.savegreenhouseresume()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB;
    request_results JSONB;
    app_data RECORD;
BEGIN
    -- Initialize an empty JSON array for the results
    result := '[]'::JSONB;

    -- Loop through the selected application data
    FOR app_data IN (
       SELECT
           application_id AS application_id,
           resume AS resume
       FROM greenhouse_reference
       WHERE resume_saved = false and resume is not null
       ORDER BY created_at ASC
       LIMIT 50
    )
    LOOP
        -- Convert the row to JSON
        request_results := row_to_json(app_data);
        
        -- Make the HTTP request for each application data
        SELECT
            net.http_post(
                url := 'https://preprod.aglinthq.com/api/greenhouse/saveResume',
                body := request_results
            ) INTO request_results;

        -- UPDATE greenhouse_reference
        -- SET resume_saved = true
        -- WHERE application_id = app_data.application_id;
        
        -- Append the request result to the result array
        result := result || jsonb_build_object('request_result', request_results);
    END LOOP;


    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;


