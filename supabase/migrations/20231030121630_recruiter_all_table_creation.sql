create extension if not exists "http" with schema "extensions";

create extension if not exists "pg_cron" with schema "extensions";

create extension if not exists "vector" with schema "extensions";


create table "public"."candidates" (
    "id" uuid not null default uuid_generate_v4(),
    "created_at" timestamp with time zone not null default now(),
    "first_name" text not null,
    "last_name" text not null,
    "email" text not null,
    "phone" text,
    "resume" text,
    "linkedin" text,
    "company" text,
    "job_title" text,
    "job_location" text,
    "json_resume" jsonb,
    "profile_image" text default ''::text,
    "embedding" vector
);


create table "public"."job_applications" (
    "application_id" uuid not null default uuid_generate_v4(),
    "created_at" timestamp with time zone not null default now(),
    "score" numeric not null default 0,
    "feedback" jsonb,
    "used_token" jsonb[] not null default '{}'::jsonb[],
    "conversation" jsonb[] default '{}'::jsonb[],
    "emails" json default '{}'::json,
    "status" text default 'new'::text,
    "interviewing_date" timestamp without time zone default now(),
    "interview_duration" text default '00:00'::text,
    "profile_image" text default ''::text,
    "ai_interviewer_id" numeric,
    "jd_score" jsonb,
    "api_logs" jsonb not null default '{"scoreStatus": "not started"}'::jsonb,
    "last_updated_at" timestamp without time zone default now(),
    "job_id" uuid,
    "resume_text" jsonb
);


create table "public"."lever_job_reference" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "last_synced_at" timestamp without time zone default now(),
    "posting_id" uuid not null,
    "job_id" uuid not null,
    "recruiter_id" uuid
);


create table "public"."lever_reference" (
    "created_at" timestamp with time zone not null default now(),
    "last_synced" timestamp with time zone not null default now(),
    "application_id" uuid not null,
    "opportunity_id" uuid not null,
    "posting_id" uuid not null,
    "public_job_id" uuid
);


create table "public"."notify_me" (
    "id" uuid not null default uuid_generate_v4(),
    "created_at" timestamp without time zone default now(),
    "email" text not null,
    "job_id" text,
    "job_title" text
);


create table "public"."public_jobs" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "company_details" text,
    "overview" text,
    "logo" text,
    "company" text,
    "location" text,
    "job_title" text,
    "description" text,
    "skills" text[],
    "is_campus" boolean not null default false,
    "slug" text not null default ''::text,
    "job_type" text,
    "workplace_type" text,
    "screening_setting" jsonb default '{}'::jsonb,
    "screening_questions" jsonb[] default '{}'::jsonb[],
    "job_criteria" jsonb default '{}'::jsonb,
    "posted_by" text not null default 'Aglint'::text,
    "email_template" jsonb not null default '{"followup": {"body": "", "subject": ""}, "interview": {"body": "", "subject": ""}, "rejection": {"body": "", "subject": ""}, "application_received": {"body": "", "subject": ""}}'::jsonb,
    "active_status" jsonb not null default '{"closed": {"isActive": false, "timeStamp": null}, "sourcing": {"isActive": false, "timeStamp": null}, "interviewing": {"isActive": false, "timeStamp": null}}'::jsonb,
    "updated_at" timestamp without time zone default now(),
    "department" text,
    "recruiter_id" uuid not null,
    "new_screening_setting" jsonb not null default '{"interview": {"isManual": true, "qualificationRange": null}, "screening": {"isManual": true, "qualificationRange": null}, "interviewMail": {"isManual": true, "timestamp": null}, "feedbackVisible": false, "disqualifiedMail": {"isManual": true, "timestamp": null}}'::jsonb,
    "parameter_weights" jsonb not null default '{"skills": 20, "project": 20, "education": 20, "experience": 20, "certifications": 20}'::jsonb,
    "embedding" vector
);


create table "public"."recruiter" (
    "id" uuid not null default uuid_generate_v4(),
    "recruiter_type" text,
    "name" text,
    "email" text,
    "company_website" text,
    "industry" text,
    "logo" text,
    "phone_number" text,
    "primary_contact" jsonb,
    "hr_contact" jsonb,
    "available_roles" text[] not null default '{}'::text[],
    "departments" text[] not null default '{}'::text[],
    "technology_score" text[] not null default '{}'::text[],
    "company_overview" text,
    "e_o_statement" text,
    "application_process" text,
    "m_v_statement" text,
    "employment_type" jsonb not null default '{"contract": true, "fulltime": true, "parttime": true, "temporary": true, "volunteer": true, "internship": true}'::jsonb,
    "workplace_type" jsonb not null default '{"hybrid": true, "onsite": true, "offsite": true}'::jsonb,
    "email_template" jsonb not null default '{}'::jsonb,
    "company_values" text,
    "benefits" text,
    "employee_size" text,
    "office_locations" jsonb[] default '{}'::jsonb[],
    "socials" jsonb default '{"custom": {}, "twitter": "", "youtube": "", "facebook": "", "linkedin": "", "instagram": ""}'::jsonb,
    "roles" jsonb not null default '{"admin": {"sourcing": true, "screening": true, "job_posting": true, "manage_roles": true, "manage_users": {"admin": true, "recruiter": true, "interviewer": true, "human resource": true}, "edit_workflow": true, "send_interview_link": true, "view_candidates_profile": true}, "recruiter": {"sourcing": true, "screening": true, "job_posting": true, "manage_roles": false, "manage_users": {"admin": false, "recruiter": false, "interviewer": true, "human resource": false}, "edit_workflow": true, "send_interview_link": true, "view_candidates_profile": true}, "human resource": {"sourcing": true, "screening": true, "job_posting": true, "manage_roles": false, "manage_users": {"admin": false, "recruiter": true, "interviewer": true, "human resource": false}, "edit_workflow": true, "send_interview_link": true, "view_candidates_profile": true}}'::jsonb,
    "lever_key" text
);


create table "public"."recruiter_user" (
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "recruiter_id" uuid not null,
    "role" text not null default 'admin'::text,
    "first_name" text,
    "last_name" text,
    "email" text,
    "profile_image" text,
    "phone" text,
    "joined_at" timestamp with time zone default now(),
    "join_status" text not null default 'invited'::text,
    "is_deactivated" boolean default false
);


create table "public"."support_groups" (
    "id" uuid not null default uuid_generate_v4(),
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now(),
    "user_ids" uuid[] not null default '{}'::uuid[],
    "company_id" uuid
);


create table "public"."support_ticket" (
    "idx" uuid not null default uuid_generate_v4(),
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now(),
    "user_id" uuid,
    "company_id" uuid,
    "job_id" uuid not null,
    "title" text not null,
    "type" text not null,
    "action_pending" jsonb not null default '{}'::jsonb,
    "assign_to" uuid,
    "content" jsonb[] not null default '{}'::jsonb[],
    "state" text not null default 'created'::text,
    "priority" text not null default 'low'::text,
    "user_name" text not null,
    "email_updates" boolean not null default false,
    "email" text,
    "attachments" text[],
    "support_group_id" uuid,
    "application_id" uuid,
    "id" text not null default ''::text
);


CREATE UNIQUE INDEX candidates_pkey ON public.candidates USING btree (id);

CREATE UNIQUE INDEX job_applications_pkey ON public.job_applications USING btree (application_id);

CREATE UNIQUE INDEX lever_job_reference_pkey ON public.lever_job_reference USING btree (id);

CREATE UNIQUE INDEX lever_reference_pkey ON public.lever_reference USING btree (application_id);

CREATE UNIQUE INDEX notify_me_pkey ON public.notify_me USING btree (id);

CREATE UNIQUE INDEX public_jobs_pkey ON public.public_jobs USING btree (id);

CREATE UNIQUE INDEX recruiter_id_pkey ON public.recruiter USING btree (id);

CREATE UNIQUE INDEX recruiter_user_pkey ON public.recruiter_user USING btree (user_id);

CREATE UNIQUE INDEX support_groups_pkey ON public.support_groups USING btree (id);

CREATE UNIQUE INDEX support_ticket_pkey ON public.support_ticket USING btree (id);

alter table "public"."candidates" add constraint "candidates_pkey" PRIMARY KEY using index "candidates_pkey";

alter table "public"."job_applications" add constraint "job_applications_pkey" PRIMARY KEY using index "job_applications_pkey";

alter table "public"."lever_job_reference" add constraint "lever_job_reference_pkey" PRIMARY KEY using index "lever_job_reference_pkey";

alter table "public"."lever_reference" add constraint "lever_reference_pkey" PRIMARY KEY using index "lever_reference_pkey";

alter table "public"."notify_me" add constraint "notify_me_pkey" PRIMARY KEY using index "notify_me_pkey";

alter table "public"."public_jobs" add constraint "public_jobs_pkey" PRIMARY KEY using index "public_jobs_pkey";

alter table "public"."recruiter" add constraint "recruiter_id_pkey" PRIMARY KEY using index "recruiter_id_pkey";

alter table "public"."recruiter_user" add constraint "recruiter_user_pkey" PRIMARY KEY using index "recruiter_user_pkey";

alter table "public"."support_groups" add constraint "support_groups_pkey" PRIMARY KEY using index "support_groups_pkey";

alter table "public"."support_ticket" add constraint "support_ticket_pkey" PRIMARY KEY using index "support_ticket_pkey";

alter table "public"."job_applications" add constraint "job_applications_job_id_fkey" FOREIGN KEY (job_id) REFERENCES public_jobs(id) ON DELETE SET NULL not valid;

alter table "public"."job_applications" validate constraint "job_applications_job_id_fkey";

alter table "public"."lever_job_reference" add constraint "lever_job_reference_job_id_fkey" FOREIGN KEY (job_id) REFERENCES public_jobs(id) ON DELETE CASCADE not valid;

alter table "public"."lever_job_reference" validate constraint "lever_job_reference_job_id_fkey";

alter table "public"."lever_job_reference" add constraint "lever_job_reference_recruiter_id_fkey" FOREIGN KEY (recruiter_id) REFERENCES recruiter(id) ON DELETE CASCADE not valid;

alter table "public"."lever_job_reference" validate constraint "lever_job_reference_recruiter_id_fkey";

alter table "public"."lever_reference" add constraint "lever_reference_public_job_id_fkey" FOREIGN KEY (public_job_id) REFERENCES public_jobs(id) ON DELETE SET NULL not valid;

alter table "public"."lever_reference" validate constraint "lever_reference_public_job_id_fkey";

alter table "public"."public_jobs" add constraint "public_jobs_recruiter_id_fkey" FOREIGN KEY (recruiter_id) REFERENCES recruiter(id) ON DELETE CASCADE not valid;

alter table "public"."public_jobs" validate constraint "public_jobs_recruiter_id_fkey";

alter table "public"."recruiter_user" add constraint "recruiter_user_recruiter_id_fkey" FOREIGN KEY (recruiter_id) REFERENCES recruiter(id) ON DELETE CASCADE not valid;

alter table "public"."recruiter_user" validate constraint "recruiter_user_recruiter_id_fkey";

alter table "public"."recruiter_user" add constraint "recruiter_user_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."recruiter_user" validate constraint "recruiter_user_user_id_fkey";

alter table "public"."support_groups" add constraint "support_groups_company_id_fkey" FOREIGN KEY (company_id) REFERENCES recruiter(id) ON DELETE CASCADE not valid;

alter table "public"."support_groups" validate constraint "support_groups_company_id_fkey";

alter table "public"."support_ticket" add constraint "support_ticket_company_id_fkey" FOREIGN KEY (company_id) REFERENCES recruiter(id) ON DELETE CASCADE not valid;

alter table "public"."support_ticket" validate constraint "support_ticket_company_id_fkey";

alter table "public"."support_ticket" add constraint "support_ticket_job_id_fkey" FOREIGN KEY (job_id) REFERENCES public_jobs(id) ON DELETE CASCADE not valid;

alter table "public"."support_ticket" validate constraint "support_ticket_job_id_fkey";

alter table "public"."support_ticket" add constraint "support_ticket_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."support_ticket" validate constraint "support_ticket_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.batchcalcresumejdscore()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB;
    request_results JSONB;
    app_id UUID;
BEGIN
    -- Initialize an empty JSON array for the results
    result := '[]'::JSONB;

    -- Loop through the selected application IDs
    FOR app_id IN (
        SELECT application_id
        FROM job_applications
        WHERE api_logs->>'scoreStatus' = 'not started'
        ORDER BY created_at ASC
        LIMIT 5
    )
    LOOP
        -- Make the HTTP request for each application_id
        SELECT
            net.http_post(
                url := 'https://us-central1-aglint-cloud-381414.cloudfunctions.net/resume-score-gen',
                body := jsonb_build_object('application_id', app_id)
            ) INTO request_results;

        -- Append the request result to the result array
        result := result || jsonb_build_object('request_result', request_results);
    END LOOP;

    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_present_scheduled_jobs()
 RETURNS SETOF json
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
    SELECT
      json_build_object(
        'job_id', id::uuid,
        'job_title', job_title::text,
        'time_stamp', TO_TIMESTAMP(active_status -> 'interviewing' ->> 'timeStamp', 'YYYY-MM-DD')::timestamp,
        'current_date', current_date::timestamp
      )
    FROM
      public.public_jobs
    WHERE
    active_status -> 'closed' ->> 'isActive' = 'false' AND
      active_status -> 'interviewing' ->> 'timeStamp' IS NOT NULL
      AND to_timestamp(
        active_status -> 'interviewing' ->> 'timeStamp',
        'YYYY-MM-DD'
      ) = current_date;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.interviewing_state_active()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE public_jobs
  SET
    active_status = jsonb_set(
      active_status,
      '{interviewing, isActive}',
      'true',
      true
    )
  WHERE
    active_status -> 'closed' ->> 'isActive' = 'false' AND
    active_status -> 'interviewing' ->> 'timeStamp' IS NOT NULL
    AND to_timestamp(
      active_status -> 'interviewing' ->> 'timeStamp',
      'YYYY-MM-DD'
    ) = current_date;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.levercandidatesync()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB;
    request_results JSONB;
    app_id UUID;
BEGIN
    -- Initialize an empty JSON array for the results
    result := '[]'::JSONB;

    -- Loop through the selected application IDs
    FOR app_id IN (
        SELECT job_id
        FROM lever_job_reference
        ORDER BY created_at ASC
    )
    LOOP
        -- Make the HTTP request for each application_id
        SELECT
            net.http_post(
                url := 'https://preprod.aglinthq.com/api/lever/candidateSync',
                body := jsonb_build_object('job_id', app_id)
            ) INTO request_results;

        -- Append the request result to the result array
        result := result || jsonb_build_object('request_result', request_results);
    END LOOP;

    -- Return the final result as a JSONB array
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.move_scheduled_jobs_sourcing_to_active()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE public_jobs
  SET
    active_status = jsonb_set(
      active_status,
      '{sourcing, isActive}',
      'true',
      true
    )
  WHERE
    active_status -> 'closed' ->> 'isActive' = 'false'
    AND active_status -> 'sourcing' ->> 'timeStamp' IS NOT NULL
    AND to_date(
      active_status -> 'sourcing' ->> 'timeStamp',
      'YYYY-MM-DD'
    ) = current_date;
END;
$function$
;


